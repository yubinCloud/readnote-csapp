(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{792:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-31-50.a85984b7.png"},793:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-18-48-48.4bac74ce.png"},794:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-36-06.3ccfff86.png"},795:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-06-12.aa423b59.png"},796:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-06-48.1e5c061f.png"},797:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-38-58.843783d2.png"},798:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-39-45.9ae1d41d.png"},799:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-40-12.33223fb1.png"},800:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-38-18.397696e5.png"},801:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-53-35.8be79dd7.png"},802:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-03-07.b2529df6.png"},803:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-09-22.a95ff76b.png"},804:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-12-12.62724e30.png"},805:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-15-17.c940a65f.png"},806:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-17-08.4adc93a1.png"},848:function(t,v,a){"use strict";a.r(v);var _=a(68),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("Chapter 4 处理器体系结构 III：Y86-64 的顺序实现")]),t._v(" "),_("h1",{attrs:{id:"_4-3-y86-64-的顺序实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-y86-64-的顺序实现"}},[t._v("#")]),t._v(" 4.3 Y86-64 的顺序实现")]),t._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#_4-3-y86-64-的顺序实现"}},[t._v("4.3 Y86-64 的顺序实现")]),_("ul",[_("li",[_("a",{attrs:{href:"#_4-3-1-将处理组织成阶段"}},[t._v("4.3.1 将处理组织成阶段")])]),_("li",[_("a",{attrs:{href:"#_4-3-2-seq-的硬件结构"}},[t._v("4.3.2 SEQ 的硬件结构")])])])])])]),_("p"),t._v(" "),_("h2",{attrs:{id:"_4-3-1-将处理组织成阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-将处理组织成阶段"}},[t._v("#")]),t._v(" 4.3.1 将处理组织成阶段")]),t._v(" "),_("a-timeline",[_("a-timeline-item",[_("strong",[t._v("取指（fetch）")]),t._v("：从内存中读取地址为 PC 的指令字节。valP = PC + 指令长度。")]),t._v(" "),_("a-timeline-item",[_("strong",[t._v("译码（decode）")]),t._v("：从寄存器文件读入最多两个操作数，得到 valA、valB。通常是读入指令 rA 和 rB 字段指明的寄存器，不过也有些指令是读 %rsp 的。")]),t._v(" "),_("a-timeline-item",[_("strong",[t._v("执行（execute）")]),t._v("：ALU 要么执行指令指明的操作（根据 ifun），计算内存引用的有效地址，要么增加或减小栈指针。得到的值称为 valE。在此也有可能设置条件码，这个阶段会决定是否应该选择分支。")]),t._v(" "),_("a-timeline-item",[_("strong",[t._v("访存（memory）")]),t._v("：读写内存，读出的值为 valM。")]),t._v(" "),_("a-timeline-item",[_("strong",[t._v("写回（write back）")]),t._v("：最多可以写两个结果到寄存器文件。")]),t._v(" "),_("a-timeline-item",[_("strong",[t._v("更新 PC（PC update）")]),t._v("：将 PC 设置为下一条指令的地址。")])],1),t._v(" "),_("h3",{attrs:{id:"计算中各数值的含义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算中各数值的含义"}},[t._v("#")]),t._v(" 计算中各数值的含义")]),t._v(" "),_("p",[_("strong",[t._v("取指：")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("名称")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("含义")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("icode")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("指令码")])]),t._v(" "),_("tr",[_("td",[t._v("ifun")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("指令功能")])]),t._v(" "),_("tr",[_("td",[t._v("rA、rB")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("指令寄存器 A、B")])]),t._v(" "),_("tr",[_("td",[t._v("valC")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("指令中的常数")])])])]),t._v(" "),_("p",[_("strong",[t._v("译码：")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("名称")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("含义")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("srcA、srcB")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("寄存器 ID A、B")])]),t._v(" "),_("tr",[_("td",[t._v("dstE、dstM")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("目的寄存器 E、M")])]),t._v(" "),_("tr",[_("td",[t._v("valA、valB")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("寄存器值 A、B")])])])]),t._v(" "),_("p",[_("strong",[t._v("执行：")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("名称")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("含义")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("valE")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("ALU 运算结果")])]),t._v(" "),_("tr",[_("td",[t._v("cnd")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("分支或转移标识")])])])]),t._v(" "),_("h3",{attrs:{id:"arith-log-opq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#arith-log-opq"}},[t._v("#")]),t._v(" Arith/Log. Opq")]),t._v(" "),_("p",[_("img",{attrs:{src:a(792),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"rrmovq-和-irmovq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rrmovq-和-irmovq"}},[t._v("#")]),t._v(" rrmovq 和 irmovq")]),t._v(" "),_("p",[_("img",{attrs:{src:a(793),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"rmmovq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rmmovq"}},[t._v("#")]),t._v(" rmmovq")]),t._v(" "),_("p",[_("img",{attrs:{src:a(794),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"mrmovq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mrmovq"}},[t._v("#")]),t._v(" mrmovq")]),t._v(" "),_("p",[_("img",{attrs:{src:a(795),alt:""}})]),t._v(" "),_("ul",[_("li",[t._v("注意 "),_("code",[t._v("mrmovq D(rB), rA")]),t._v(" 指令的写法中 rA、rB 所在的先后顺序与指令编码中是相反的。")])]),t._v(" "),_("h3",{attrs:{id:"pushq、popq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pushq、popq"}},[t._v("#")]),t._v(" pushq、popq")]),t._v(" "),_("p",[_("img",{attrs:{src:a(796),alt:""}})]),t._v(" "),_("ul",[_("li",[_("code",[t._v("pushq")]),t._v(" 应该先将栈指针减去 8，即使栈指针的更新实际上是在内存操作完成后才进行的。")]),t._v(" "),_("li",[_("code",[t._v("pop")]),t._v(" 应该首先读内存，然后再增加栈指针。")])]),t._v(" "),_("h3",{attrs:{id:"jumps"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jumps"}},[t._v("#")]),t._v(" jumps")]),t._v(" "),_("p",[_("img",{attrs:{src:a(797),alt:""}})]),t._v(" "),_("ul",[_("li",[t._v("跳转的实现：在执行阶段，检查条件码和跳转条件来确定是否要选择分支，产生一个一位信号 Cnd。在更新 PC 阶段，检查这个标志，如果这个标志为 1，就将 PC 设为 valC（跳转目标），如果为 0，就设为 valP（下一条指令的地址）。")])]),t._v(" "),_("h3",{attrs:{id:"call"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#call"}},[t._v("#")]),t._v(" call")]),t._v(" "),_("p",[_("img",{attrs:{src:a(798),alt:""}})]),t._v(" "),_("ul",[_("li",[t._v("对指令 call，我们要将 valP，也就是 call 指令后紧跟着的那条指令的地址，压入栈中。在更新 PC 阶段，将 PC 设为 valC，也就是调用的目的地。")])]),t._v(" "),_("h3",{attrs:{id:"ret"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ret"}},[t._v("#")]),t._v(" ret")]),t._v(" "),_("p",[_("img",{attrs:{src:a(799),alt:""}})]),t._v(" "),_("ul",[_("li",[t._v("对指令 ret，在更新 PC 阶段，我们将 valM，即从栈中取出的值，赋值给 PC。")])]),t._v(" "),_("h3",{attrs:{id:"conditional-move"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#conditional-move"}},[t._v("#")]),t._v(" Conditional Move")]),t._v(" "),_("p",[_("img",{attrs:{src:a(800),alt:""}})]),t._v(" "),_("h2",{attrs:{id:"_4-3-2-seq-的硬件结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-seq-的硬件结构"}},[t._v("#")]),t._v(" 4.3.2 SEQ 的硬件结构")]),t._v(" "),_("p",[_("img",{attrs:{src:a(801),alt:""}})]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("图片说明")]),t._v(" "),_("ul",[_("li",[t._v("浅蓝色方框：硬件单元，如内存、ALU 等")]),t._v(" "),_("li",[t._v("灰色方框：控制逻辑，用 HCL 描述")]),t._v(" "),_("li",[t._v("白色椭圆框：信号标识")]),t._v(" "),_("li",[t._v("粗线：宽度为字长的数据（64位）")]),t._v(" "),_("li",[t._v("细线：宽度为字节或更窄的数据（4-8位）")]),t._v(" "),_("li",[t._v("虚线：单个位的数据")])])]),t._v(" "),_("h3",{attrs:{id:"_1-取指阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-取指阶段"}},[t._v("#")]),t._v(" （1）取指阶段")]),t._v(" "),_("p",[_("img",{attrs:{src:a(802),alt:""}})]),t._v(" "),_("p",[_("strong",[t._v("预定义的单元：")])]),t._v(" "),_("ul",[_("li",[t._v("PC：存储 PC 的寄存器")]),t._v(" "),_("li",[t._v("指令内存：读出 10 个字节（PC ~ PC+9），发出指令地址不合法的信号（imem_error）")]),t._v(" "),_("li",[t._v("Split：把指令字节分为 icode 和 ifun")]),t._v(" "),_("li",[t._v("Align：把读出的字节放入寄存器和常数字（valC）中")])]),t._v(" "),_("p",[_("strong",[t._v("控制逻辑：")])]),t._v(" "),_("ul",[_("li",[t._v("instr_valid：指令是否有效？")]),t._v(" "),_("li",[t._v("icode、ifun：指令地址无效时（检查 imem_error 信号）生成 no-op 指令；有效时是指令的相应字段")]),t._v(" "),_("li",[t._v("need_regids：指令是否有寄存器字节？")]),t._v(" "),_("li",[t._v("need_valC：指令中是否有常数字？")])]),t._v(" "),_("h3",{attrs:{id:"_2-译码和写回阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-译码和写回阶段"}},[t._v("#")]),t._v(" （2）译码和写回阶段")]),t._v(" "),_("p",[_("img",{attrs:{src:a(803),alt:""}})]),t._v(" "),_("p",[_("strong",[t._v("寄存器文件：")])]),t._v(" "),_("ul",[_("li",[t._v("读端口 A, B")]),t._v(" "),_("li",[t._v("写端口 E, M")]),t._v(" "),_("li",[t._v("地址为寄存器 ID 或者是 15（0xF），15 时无法访问")])]),t._v(" "),_("p",[_("strong",[t._v("控制逻辑：")])]),t._v(" "),_("ul",[_("li",[t._v("srcA, srcB: 读端口地址")]),t._v(" "),_("li",[t._v("dstE, dstM: 写端口地址")])]),t._v(" "),_("p",[_("strong",[t._v("信号：")])]),t._v(" "),_("ul",[_("li",[t._v("Cnd: 标明是否触发条件转移。在执行阶段计算出Cnd条件信号。")])]),t._v(" "),_("h3",{attrs:{id:"_3-执行阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-执行阶段"}},[t._v("#")]),t._v(" （3）执行阶段")]),t._v(" "),_("p",[_("img",{attrs:{src:a(804),alt:""}})]),t._v(" "),_("p",[_("strong",[t._v("单元：")])]),t._v(" "),_("ul",[_("li",[t._v("ALU：实现四种所需的功能；生成条件码")]),t._v(" "),_("li",[t._v("CC：包含三个条件码的寄存器")]),t._v(" "),_("li",[t._v("cond：计算条件转移或跳转标识")])]),t._v(" "),_("p",[_("strong",[t._v("控制逻辑：")])]),t._v(" "),_("ul",[_("li",[t._v("Set CC：是否加载条件码寄存器？")]),t._v(" "),_("li",[t._v("ALU A：数据 A 送入 ALU")]),t._v(" "),_("li",[t._v("ALU fun：ALU 执行哪个功能")])]),t._v(" "),_("h3",{attrs:{id:"_4-访存阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-访存阶段"}},[t._v("#")]),t._v(" （4）访存阶段")]),t._v(" "),_("p",[_("img",{attrs:{src:a(805),alt:""}})]),t._v(" "),_("p",[_("strong",[t._v("控制逻辑：")])]),t._v(" "),_("ul",[_("li",[t._v("stat：指令的状态是什么")]),t._v(" "),_("li",[t._v("Mem.read：是否读数据字")]),t._v(" "),_("li",[t._v("Mem.write：是否写数据字")]),t._v(" "),_("li",[t._v("Mem.addr：选择地址")]),t._v(" "),_("li",[t._v("Mem.data：选择数据")])]),t._v(" "),_("h3",{attrs:{id:"_5-更新-pc-阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-更新-pc-阶段"}},[t._v("#")]),t._v(" （5）更新 PC 阶段")]),t._v(" "),_("p",[_("img",{attrs:{src:a(806),alt:""}})]),t._v(" "),_("ul",[_("li",[t._v("新 PC：选取下一个 PC 的值")])])],1)}),[],!1,null,null,null);v.default=s.exports}}]);